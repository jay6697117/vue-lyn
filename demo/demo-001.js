// 脚本执行

console.log(1); // 1

// 宏任务
setTimeout(() => {
  console.log(2); //4
}, 0);

const p = new Promise(resolve => {
  // 宏任务
  setTimeout(() => {
    console.log(3); //5
    resolve();
  }, 1000);
  console.log(4); //2
});

p.then(() => {
  console.log(5); //6
});

console.log(6); //3

// 执行过程
// 输出结果为： 1 4 6 2 3 5

// a. 脚本放入执行栈开始实行

// b. 执行到console.log(1), 输入1

// c. 执行到setTimeout，遇到宏任务，将其挂起，由于延时 0ms，将在 4ms后在宏任务队列产生一个定时事件, 我们叫定时A

// d. 程序继续向下执行，执行new Promise()，并运行其参数，遇到第二个定时任务(宏任务)，叫它定时B，并将其挂起，执行console.log(4), 输出4

// e. 遇到微任务p.then(), 将其挂起

// f. 向下执行遇到console.log(6), 输出6

// g. 执行栈清空，读取微任务队列，发现为空，因为p.then()含没有就绪，它的就绪依赖与第一个定时任务（定时A）的执行

// h. 执行栈为空，微任务队列为空，执行浏览器的渲染动作

// i. 读取宏任务队列，读取第一个就绪的宏任务，为定时任务A，将其回调函数放入执行栈开始执行，执行console.log(2)， 输入2

// j. 执行栈清空，微任务队列为空，渲染

// k. 开始执行下一个就绪的宏任务，定时任务B，并将其回调函数放入执行栈执行，执行console.log(3), 输出3，并执行resolve()， p.then()就绪，在微任务队列放入相应的事件

// o. 执行栈清空，读取微任务队列，发现不为空，读取第一个就绪的事件，并将其对应的回调函数放入执行栈执行，执行console.log(5)， 输出5

// p. 执行栈清空，微任务队列为空，渲染，然后发现宏任务队列为空，本次脚本执行彻底结束
